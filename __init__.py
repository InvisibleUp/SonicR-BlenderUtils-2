#!/usr/bin/env python3

# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

import bpy
from pathlib import Path
from itertools import *
import json
from bpy.props import StringProperty, FloatProperty
from bpy_extras.io_utils import ImportHelper, orientation_helper_factory
import mathutils
from kaitaistruct import KaitaiStream
from kaitaidefs import *

bl_info = {
    "name": "Sonic R Importers",
    "author": "InvisibleUp",
    "version": (2, 0),
    "blender": (4, 0, 0),
    "location": "File > Import-Export",
    "description": "Imports Sonic R model files.",
    "warning": "",
    "wiki_url": "",
    "category": "Import-Export",
}

IOOBJOrientationHelper = orientation_helper_factory("IOOBJOrientationHelper", axis_forward='-Z', axis_up='Y')
class ImportSRT(bpy.types.Operator, ImportHelper, IOOBJOrientationHelper):
    bl_idname = "import_scene.srt"
    bl_label = "Import Sonic R Track"
    bl_options = {'PRESET', 'UNDO'}

    filename_ext = ".bin"
    filter_glob = StringProperty(
        default="*.bin;*.srt",
        options={'HIDDEN'},
    )

    global_scale = FloatProperty(
        name="Scale",
        min=0.01, max=1000.0,
        default=1.0,
    )

    def execute(self, context):
        keywords = self.as_keywords(
            ignore=("axis_forward", "axis_up", "filter_glob", "split_mode")
        )
        return loadTrk(context, **keywords)

def menu_func_import(self, context):
    self.layout.operator(ImportSRT.bl_idname, text="Sonic R Track (.bin)")

def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_import.append(menu_func_import)

def unregister():
    bpy.utils.unregister_module(__name__)
    bpy.types.INFO_MT_file_import.remove(menu_func_import)

if __name__ == "__main__":
    register()

def makeImage(name, path):
    image = bpy.data.images.load(path)
    image.name = name
    return image

''' Generate a material for a given texture '''
def makeMaterial(name, image):
    mat = bpy.data.materials.new(name)
    mat.use_nodes = True

    # generated by https://extensions.blender.org/add-ons/node-to-python/
    material = mat.node_tree
    material.color_tag = 'NONE'
    material.description = ""
    material.default_group_node_width = 140

    #material interface

    #initialize material nodes
    #node Texture Coordinate
    texture_coordinate = material.nodes.new("ShaderNodeTexCoord")
    texture_coordinate.name = "Texture Coordinate"
    texture_coordinate.from_instancer = False

    #node Light Path
    light_path = material.nodes.new("ShaderNodeLightPath")
    light_path.name = "Light Path"

    #node Emit Only To Camera
    emit_only_to_camera = material.nodes.new("ShaderNodeMixShader")
    emit_only_to_camera.label = "Emit Only To Camera"
    emit_only_to_camera.name = "Emit Only To Camera"

    #node Material Output
    material_output = material.nodes.new("ShaderNodeOutputMaterial")
    material_output.name = "Material Output"
    material_output.is_active_output = True
    material_output.target = 'ALL'
    #Displacement
    material_output.inputs[2].default_value = (0.0, 0.0, 0.0)
    #Thickness
    material_output.inputs[3].default_value = 0.0

    #node Color Attribute
    color_attribute = material.nodes.new("ShaderNodeVertexColor")
    color_attribute.name = "Color Attribute"
    color_attribute.layer_name = ""

    #node Add Vertex Color
    add_vertex_color = material.nodes.new("ShaderNodeVectorMath")
    add_vertex_color.label = "Add Vertex Color"
    add_vertex_color.name = "Add Vertex Color"
    add_vertex_color.operation = 'ADD'

    #node Adjust Vertex Color
    adjust_vertex_color = material.nodes.new("ShaderNodeVectorMath")
    adjust_vertex_color.label = "Adjust Vertex Color"
    adjust_vertex_color.name = "Adjust Vertex Color"
    adjust_vertex_color.operation = 'ADD'
    #Vector_001
    adjust_vertex_color.inputs[1].default_value = (-0.5, -0.5, -0.5)

    #node Image Texture
    image_texture = material.nodes.new("ShaderNodeTexImage")
    image_texture.name = "Image Texture"
    image_texture.extension = 'REPEAT'
    image_texture.image_user.frame_current = 0
    image_texture.image_user.frame_duration = 1
    image_texture.image_user.frame_offset = 4
    image_texture.image_user.frame_start = 1
    image_texture.image_user.tile = 0
    image_texture.image_user.use_auto_refresh = False
    image_texture.image_user.use_cyclic = False
    image_texture.interpolation = 'Closest'
    image_texture.projection = 'FLAT'
    image_texture.projection_blend = 0.0
    image_texture.image = image

    #node Transparent BSDF
    transparent_bsdf = material.nodes.new("ShaderNodeBsdfTransparent")
    transparent_bsdf.name = "Transparent BSDF"
    #Color
    transparent_bsdf.inputs[0].default_value = (1.0, 1.0, 1.0, 1.0)

    #node Emission
    emission = material.nodes.new("ShaderNodeEmission")
    emission.name = "Emission"
    #Strength
    emission.inputs[1].default_value = 1.0

    #node Mix Alpha
    mix_alpha = material.nodes.new("ShaderNodeMixShader")
    mix_alpha.label = "Mix Alpha"
    mix_alpha.name = "Mix Alpha"


    #Set locations
    texture_coordinate.location = (-752.1420288085938, 172.89166259765625)
    light_path.location = (215.29904174804688, 576.9533081054688)
    emit_only_to_camera.location = (471.49346923828125, 344.90069580078125)
    material_output.location = (703.8551025390625, 367.49798583984375)
    color_attribute.location = (-746.0689697265625, 411.94573974609375)
    add_vertex_color.location = (-252.72947692871094, 380.2495422363281)
    adjust_vertex_color.location = (-502.159423828125, 463.3686218261719)
    image_texture.location = (-555.6151123046875, 191.15330505371094)
    transparent_bsdf.location = (-37.10700988769531, 387.06463623046875)
    emission.location = (-38.904380798339844, 288.57635498046875)
    mix_alpha.location = (215.2847900390625, 231.6190643310547)

    #Set dimensions
    texture_coordinate.width, texture_coordinate.height = 140.0, 100.0
    light_path.width, light_path.height = 140.0, 100.0
    emit_only_to_camera.width, emit_only_to_camera.height = 140.0, 100.0
    material_output.width, material_output.height = 140.0, 100.0
    color_attribute.width, color_attribute.height = 140.0, 100.0
    add_vertex_color.width, add_vertex_color.height = 140.0, 100.0
    adjust_vertex_color.width, adjust_vertex_color.height = 140.0, 100.0
    image_texture.width, image_texture.height = 240.0, 100.0
    transparent_bsdf.width, transparent_bsdf.height = 140.0, 100.0
    emission.width, emission.height = 140.0, 100.0
    mix_alpha.width, mix_alpha.height = 140.0, 100.0

    #initialize material links
    #light_path.Is Camera Ray -> emit_only_to_camera.Fac
    material.links.new(light_path.outputs[0], emit_only_to_camera.inputs[0])
    #emit_only_to_camera.Shader -> material_output.Surface
    material.links.new(emit_only_to_camera.outputs[0], material_output.inputs[0])
    #texture_coordinate.UV -> image_texture.Vector
    material.links.new(texture_coordinate.outputs[2], image_texture.inputs[0])
    #image_texture.Color -> add_vertex_color.Vector
    material.links.new(image_texture.outputs[0], add_vertex_color.inputs[1])
    #color_attribute.Color -> adjust_vertex_color.Vector
    material.links.new(color_attribute.outputs[0], adjust_vertex_color.inputs[0])
    #add_vertex_color.Vector -> emission.Color
    material.links.new(add_vertex_color.outputs[0], emission.inputs[0])
    #mix_alpha.Shader -> emit_only_to_camera.Shader
    material.links.new(mix_alpha.outputs[0], emit_only_to_camera.inputs[2])
    #image_texture.Alpha -> mix_alpha.Fac
    material.links.new(image_texture.outputs[1], mix_alpha.inputs[0])
    #transparent_bsdf.BSDF -> mix_alpha.Shader
    material.links.new(transparent_bsdf.outputs[0], mix_alpha.inputs[1])
    #emission.Emission -> mix_alpha.Shader
    material.links.new(emission.outputs[0], mix_alpha.inputs[2])
    #adjust_vertex_color.Vector -> add_vertex_color.Vector
    material.links.new(adjust_vertex_color.outputs[0], add_vertex_color.inputs[0])
    
    return mat

def createAllMaterials(texlist):
    # Create required materials
    materials = []
    for path in texlist:
        name = Path(path).stem
        image = makeImage(name, path)
        materials.append(makeMaterial(name, image))
    return materials

def convertTrk(srt: Srt, metadata):
    new_objects = []  # put new objects here
    materials = createAllMaterials(metadata.textures)
    
    for trkPart in srt.trkparts:
        # create a new mesh
        me = bpy.data.meshes.new("Trk") 
        ob = bpy.data.objects.new("Trk", me)
        
        # add all materials to mesh
        for material in materials:
            me.materials.append(material)

        faces = []

        # parse faces (list of tuples of vertex indices)
        for i, f in enumerate(
            zip(
                range(0, len(trkPart.vtxs)),
                range(2, len(trkPart.vtxs)),
                range(3, len(trkPart.vtxs)),
                range(1, len(trkPart.vtxs)),
            )
        ):
            if i % 2 == 1: continue
            faces.append(list(f))

        # to mesh
        face_lengths = list(map(len, faces))

        me.vertices.add(trkPart.num_vtxs)
        me.loops.add(sum(face_lengths))
        me.polygons.add(trkPart.num_faces)
        uvtex = me.uv_layers.new()
        colormap = me.data.color_attributes.new(
            name='',
            type='BYTE_COLOR',
            domain='POINT'
        )

        for src, dst, color in zip(trkPart.vtxs, me.vertices, colormap.data):
            dst.co = mathutils.Vector(src.x, src.y, src.z)
            color.data.color = [src.r, src.g, src.b, 1]

        # vertex color
        me.vertices.foreach_set("")

        vertex_indices = list(chain.from_iterable(faces))
        loop_starts = list(islice(chain([0], accumulate(face_lengths)), len(faces)))

        me.polygons.foreach_set("loop_total", face_lengths)
        me.polygons.foreach_set("loop_start", loop_starts)
        me.polygons.foreach_set("vertices", vertex_indices)
        
        # no edges - calculate them
        me.update(calc_edges=True, calc_tessface=True)
        me.validate()

        for p, f in zip(me.polygons, trkPart.faces):
            # set textures
            uvtex.uv[0].vector = [f.ta_x, f.ta_y]
            uvtex.uv[1].vector = [f.tb_x, f.tb_y]
            uvtex.uv[2].vector = [f.tc_x, f.tb_y]
            uvtex.uv[3].vector = [f.td_x, f.tb_y]
            p.material_index = f.tpage
        
        ob = bpy.data.objects.new("Trk", me)
        new_objects.append(ob)
        
    # Decoration parts
    '''for a in range(0, len(DecoParts)):
        # create a new mesh
        me = bpy.data.meshes.new("Deco") 
        ob = bpy.data.objects.new("Deco", me)
        
        # add all materials to mesh
        for material in materials:
            me.materials.append(material)
        
        verts = []
        tints = []
        faces = []
        x = DecoParts[a]

        # parse verts (list of tuples of coordinates)
        verts = list(zip(*[iter(x['FaceVtxs'])] * 3))

        # parse vtx colors
        tints = list(zip(*[iter(x['ColorVtxs'])] * 3))
            
        # parse textures
        texs = list(zip(*[iter(x['TriTexVtxs']+x['QuadTexVtxs'])] * 2))

        # parse faces (list of tuples of vertex indices)
        faces = list(zip(*[iter(x['TriIdxs'])] * 3)) + \
            list(zip(*[iter(x['QuadIdxs'])] * 4))

        #print("Verts and faces parsed!")
        #print("V: ", verts, len(verts))
        #print("F: ", faces, len(faces))
        #print("T: ", tints, len(tints))

        # to mesh
        face_lengths = tuple(map(len, faces))

        me.vertices.add(len(verts))
        me.loops.add(sum(face_lengths))
        me.polygons.add(len(faces))
        uvtex = me.uv_textures.new()
        colormap = me.vertex_colors.new()

        me.vertices.foreach_set("co", tuple(chain.from_iterable(verts)))
        #me.vertex_colors.foreach_set("co", tuple(chain.from_iterable(tints)))

        vertex_indices = tuple(chain.from_iterable(faces))
        loop_starts = tuple(islice(chain([0], accumulate(face_lengths)), len(faces)))
        
        #print("Indices set!")
        #print(vertex_indices)
        #print(loop_starts)

        me.polygons.foreach_set("loop_total", face_lengths)
        me.polygons.foreach_set("loop_start", loop_starts)
        me.polygons.foreach_set("vertices", vertex_indices)
        
        # no edges - calculate them
        me.update(calc_edges=True, calc_tessface=True)
        me.validate()

        # set colors
        j = 0
        pc = 0
        
        for p in me.polygons:
            for i in p.loop_indices:
                
                # Set colors
                vIdx = me.loops[i].vertex_index
                #print(vIdx)
                tint = tints[vIdx]
                colormap.data[j].color = tint
                
                # Set textures
                me.uv_layers[0].data[j].uv = texs[j]
                
                j += 1
            p.material_index = (x['TriTexPages']+x['QuadTexPages'])[pc]
            pc += 1 
            
        #print(len(colormap.data), j, sum(face_lengths))

        # no edges - calculate them
        #me.update(calc_edges=True)
        #me.validate()
        
        ob = bpy.data.objects.new("Deco", me)
        new_objects.append(ob)'''
        
    return new_objects

def loadTrk(context, filepath):
    with open(filepath, mode='rb') as f: 
        stream = KaitaiStream(f)
        track = Srt(stream)

    with open('./trackmeta/island.json', mode='r') as f:
        metadata = json.load(f)

    objlist = convertTrk(track, metadata)
    scn = bpy.context.scene
    
    for o in scn.objects:
        o.select = False
    
    for o in objlist:
        scn.objects.link(o)
        o.select = True

    return {'FINISHED'}
